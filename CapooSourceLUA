-- è…³æœ¬ä¿¡æ¯
local scriptName = [=====[ Mod menu for Mini World]=====]
local scriptVersion = '2.4'
local scriptAuthor = 'SkyCapoo'
local startToast = ''
-- 0 - ç„¡æª¢æŸ¥ï¼›1 - æª¢æŸ¥åŒ…åï¼›2 - æª¢æŸ¥åŒ…åå’Œç‰ˆæœ¬
local checkTarget = 1 

-- ç›®æ¨™éŠæˆ²ä¿¡æ¯
local targetName = [=====[Mini World]=====]
local targetPkg = 'com.playmini.miniworld'
local targetVersion = [=====[1.7.11]=====]
local targetBuild = 67339

local processes = gg.getListItems()
local gameProcess = nil
local gameProcessName = "mini world" -- ç¢ºä¿é€™æ˜¯ã€Šè¿·ä½ ä¸–ç•Œã€‹çš„é€²ç¨‹åç¨±
-- ä½¿ç”¨ gg.getTargetInfo() ä¾†ç²å–ç•¶å‰é¸ä¸­çš„é€²ç¨‹ä¿¡æ¯

APP = gg.getTargetInfo()
SJ = os.date("ğ’…’å½“å‰æ—¶é—´%Yå¹´%mæœˆ%dæ—¥%Hæ—¶%Måˆ†%Sç§’ğ’…’")

gg.toast("loading UI")
loadYunLuaGroup("5C3C4E3813681C4C204C35346F1B4C2F7EFF612D2B22176FF346535E1C0B1E493339036EE15318")
function init()
	stab = _ENV["åˆ†é¡µ"]
	ttitle = _ENV["æ ‡é¢˜"]
	xfcpic = _ENV["æ‚¬æµ®çª—å›¾æ ‡"]
end
gg.toast("æ­£åœ¨æ•´ç†æ ¸å¿ƒä»£ç¢¼-å¯èƒ½æ™‚é–“è¼ƒé•·è«‹è€å¿ƒç­‰å¾…")
gg.sleep(320)
gg.toast("10ï¼…..")
function svip(af,ag) local gn,Dm={},{} for i,v in tostring(af):gmatch("%[(%s*%p*%d+)%] = '(.-)'") do gn[#gn+1]=v Dm[#Dm+1]=tonumber(i) end local GT=gg.choice(gn,2018,ag) local GY=Dm[GT] return GY end
gg.sleep(320)
function readString(address, length) local char = {} for i = 0, length - 1 do local value = GetValue(address + i * 0x1, 1) if value ~= 0 then char[#char + 1] = value & 0xFF else break end end return string.char(table.unpack(char)) end
function Split(szFullString, szSeparator) local nFindStartIndex = 1 local nSplitIndex = 1 local nSplitArray = {} while true do local nFindLastIndex = string.find(szFullString, szSeparator, nFindStartIndex) if not nFindLastIndex then nSplitArray[nSplitIndex] = string.sub(szFullString, nFindStartIndex, string.len(szFullString)) break end nSplitArray[nSplitIndex] = string.sub(szFullString, nFindStartIndex, nFindLastIndex - 1) nFindStartIndex = nFindLastIndex + string.len(szSeparator) nSplitIndex = nSplitIndex + 1 end return nSplitArray end
gg.toast("15ï¼…...")
function LS(content) local _FOR_=function() return _FOR_ end local _ENV=function() return _ENV end local _UPVALUE0_=function() return _UPVALUE0_ end assert(type(content)=="") local temp={} local result={} local i=1 local ends=0 for i=1, #lines do if string.find(lines[i],"") then table.insert(temp,lines[i]) ends=ends+1 elseif string.find(lines[i],"") or string.find(lines[i],"") or string.find(lines[i],"") then ends=ends+1 if #temp==0 then table.insert(result,lines[i]) else table.insert(temp,lines[i]) end elseif string.find(lines[i],"") then ends=ends-1 if #temp==0 then table.insert(result,lines[i]) else table.insert(temp,lines[i]) end if ends==0 and #temp~=0 then table.insert(result,temp) temp={} end else if #temp==0 then table.insert(result,lines[i]) else table.insert(temp,lines[i]) end end end return result end 
gg.toast("18ï¼…...")
gg.sleep(320)
function GetAssignment(content) return string.match(content,"") end 
gg.toast("20ï¼…...")
function isSetGlobals(content) if string.find(content,"") then return true end if string.find(content,"") then return false end return false end 
gg.toast("25ï¼…...")
function FilteSpec(content) local spec="" for ia=1,string.len(spec) do local suba=""..string.sub(spec,ia,ia) content=(string.gsub(content,""..string.sub(spec,ia,ia),suba)) end return content end 
function Replace(content,locals) if isSetGlobals(content) then return content end local _i=0 local _v=0 for _i,_v in pairs(locals) do content=(string.gsub(content,_i,FilteSpec(tostring(_v)))) end return content end 
gg.toast("28ï¼…...")
function process(flines) local spots={} local funnames={} local result="" for i=1, #flines do if type(flines[i])=="" then if flines[i]~="" then name,value=GetAssignment(flines[i]) if name~=nil then if string.find(value,"") then spots[name]=nil result=result..flines[i].."" else spots[name]=Replace(value,spots) end elseif string.find(flines[i],"") then result=result..flines[i].."" local localss=string.match(flines[i],"") local tlocals=Split(localss,",") for j=1,#tlocals do spots[string.match(tlocals[j],"")]="" end else result=result..(Replace(flines[i],spots)).."" end end elseif type(flines[i]=="") then if i~=#flines then if flines[i][1]~=nil and type(flines[i][1]=="") then local funspot=string.match(flines[i][1],"") local funname= string.match(flines[i+1],""..funspot.."") if funname~=nil then flines[i][1]=(string.gsub(flines[i][1],funspot,FilteSpec(funname))) flines[i+1]="" end result=result..process(flines[i]).."" end end end end return result end 
function raw(s) for w in string.gmatch(s, "") do s=string.gsub(s,""..w,string.char(w),1) end return s end 
gg.sleep(320)
gg.toast("30ï¼…...")
function LO(ina,out) local _FOR_=function() return _FOR_ end local _ENV=function() return _ENV end local _UPVALUE0_=function() return _UPVALUE0_ end file=io.open(ina,"") script=file:read("") file:close() lines=Split(script,"") flines=LS(lines) unraw=process(flines) file=io.open(out,"") file:write(unraw) file:close() final=raw(unraw) file=io.open(out,"") file:write(final) file:close() end 
function LOO(ina) local _FOR_=function() return _FOR_ end local _ENV=function() return _ENV end local _UPVALUE0_=function() return _UPVALUE0_ end LO(ina,ina) end ggg = {} for k, v in pairs(gg) do ggg[k] = v end lde,mnsj={},{Dj="0.01",dv={},lz="/sdcard/.zbb",r={}} 
gg.toast("32ï¼…...")
function lde.qb()table.remove(bc,#bc)table.remove(bc,#bc)end 
gg.toast("35ï¼…...")
function readValue(read) local bf={} for i,v in ipairs(read) do bf[i]={address=v[1],flags=v[2]} end bf=gg.getValues(bf) for i=1,#bf do bf[i]=bf[i].value end return bf end 
gg.sleep(320)
gg.toast("40ï¼…...")
function nc_offset(addr,tablex,tt) for i,v in ipairs(tablex) do if v[4]==true then gg.addListItems({{address=addr+v[3],flags=v[2],value=v[1],freeze=v[4]}})else gg.setValues({{address=addr+v[3],flags=v[2],value=v[1]}}) end end gg.toast((tt or "").."å¼€å¯æˆåŠŸ") end 
function getso(So_name) return gg.getRangesList(So_name)[1].start end 
gg.toast("45ï¼…...")
function BaAdd(add) t=gg.getValues({[1]={address=add,flags=4}}) return t[1].value&0xFFFFFFFF end 
function readPointer(Add,Item) for i=1,(#Item-1) do Add=BaAdd(Add+Item[i]) end return Add+Item[#Item] end 
gg.sleep(320)
gg.toast("50ï¼…...")
function getnc(Name,nc) local t=gg.getRangesList(Name) for i, v in ipairs(t) do if v.state==nc then return v.start end end end 
gg.toast("55ï¼…...")
function Xilst() local iihj = ilht+1 gg.setRanges(4) local dataType = 4 local tb1 = {{ilht, 0},{iihj, 0x400},} local tb2 = {{ 0 }, } SearchWrite(tb1, tb2, dataType) sl=gg.getResultCount() jg=gg.getResults(100) for i = 1, sl do dzy=jg[i].address gg.addListItems({[1] = {address = dzy,flags = gg.TYPE_DWORD,freeze = true,value = ilht}}) end end 
gg.sleep(420)
gg.toast("60ï¼…...") 
function typetab(array, type) local datatype = {} for i = 1, #array do if Assert(array[i].type) then table.insert(datatype, i, array[i].type) else if Assert(type) then table.insert(datatype, i, type) else return false end end end return true, datatype end 
gg.toast("65ï¼…...")
function editData(qmnb,qmxg)gg.setVisible(false)gg.clearResults()qmnbv=qmnb[3]["value"]or qmnb[3][1]qmnbt=qmnb[3]["type"]or qmnb[3][2]qmnbn=qmnb[2]["name"]or qmnb[2][1]gg.setRanges(qmnb[1]["memory"]or qmnb[1][1])gg.searchNumber(qmnbv,qmnbt)gg.refineNumber(qmnbv,qmnbt)sz=gg.getResultCount()if sz==0 then gg.toast(qmnbn.."å¼€å¯å¤±è´¥")else sl=gg.getResults(999999)for i=1,sz do pdsz=true for v=4,#qmnb do if pdsz==true then pysz={{}}pysz[1].address=sl[i].address+(qmnb[v]["offset"]or qmnb[v][2])pysz[1].flags=qmnb[v]["type"]or qmnb[v][3]szpy=gg.getValues(pysz)tzszpd=tostring(qmnb[v]["lv"]or qmnb[v][1]):gsub(",","")pyszpd=tostring(szpy[1].value):gsub(",","")if tzszpd==pyszpd then pdjg=true pdsz=true else pdjg=false pdsz=false end end end if pdjg==true then szpy=sl[i].address for x=1,#qmxg do xgsz=qmxg[x]["value"]or qmxg[x][1]xgpy=szpy+(qmxg[x]["offset"]or qmxg[x][2])xglx=qmxg[x]["type"]or qmxg[x][3]xgdj=qmxg[x]["freeze"]or qmxg[x][4]xg={{address=xgpy,flags=xglx,value=xgsz}}if xgdj==true then xg[1].freeze=xgdj gg.addListItems(xg)else gg.setValues(xg)end end xgjg=true end end if xgjg==true then gg.toast(qmnbn.."å¼€å¯æˆåŠŸ")else gg.toast(qmnbn.."å¼€å¯å¤±è´¥")end end end D=gg.TYPE_DWORD E=gg.TYPE_DOUBLE F=gg.TYPE_FLOAT W=gg.TYPE_WORD B=gg.TYPE_BYTE X=gg.TYPE_XOR Q=gg.TYPE_QWORD 
function xgxc(szpy, qmxg) for x = 1, #(qmxg) do xgpy = szpy + qmxg[x]["offset"] xglx = qmxg[x]["type"] xgsz = qmxg[x]["value"] xgdj = qmxg[x]["freeze"] if xgdj == nil or xgdj == "" then gg.setValues({[1] = {address = xgpy, flags = xglx, value = xgsz}}) else gg.addListItems({[1] = {address = xgpy, flags = xglx, freeze = xgdj, value = xgsz}}) end xgsl = xgsl + 1 xgjg = true end end 
gg.sleep(520)
gg.toast("70ï¼…...")
function split(szFullString, szSeparator) local nFindStartIndex = 1 local nSplitIndex = 1 local nSplitArray = {} while true do local nFindLastIndex = string.find(szFullString, szSeparator, nFindStartIndex) if not nFindLastIndex then nSplitArray[nSplitIndex] = string.sub(szFullString, nFindStartIndex, string.len(szFullString)) break end nSplitArray[nSplitIndex] = string.sub(szFullString, nFindStartIndex, nFindLastIndex - 1) nFindStartIndex = nFindLastIndex + string.len(szSeparator) nSplitIndex = nSplitIndex + 1 end return nSplitArray end function xgxc(szpy, qmxg) for x = 1, #(qmxg) do xgpy = szpy + qmxg[x]["offset"] xglx = qmxg[x]["type"] xgsz = qmxg[x]["value"] xgdj = qmxg[x]["freeze"] if xgdj == nil or xgdj == "" then gg.setValues({[1] = {address = xgpy, flags = xglx, value = xgsz}}) else gg.addListItems({[1] = {address = xgpy, flags = xglx, freeze = xgdj, value = xgsz}}) end xgsl = xgsl + 1 xgjg = true end end
 function xqmnb(qmnb) gg.clearResults() gg.setRanges(qmnb[1]["memory"]) gg.searchNumber(qmnb[3]["value"], qmnb[3]["type"]) if gg.getResultCount() == 0 then gg.toast(qmnb[2]["name"] .. "å¼€å¯å¤±è´¥") else gg.refineNumber(qmnb[3]["value"], qmnb[3]["type"]) gg.refineNumber(qmnb[3]["value"], qmnb[3]["type"]) gg.refineNumber(qmnb[3]["value"], qmnb[3]["type"]) if gg.getResultCount() == 0 then gg.toast(qmnb[2]["name"] .. "å¼€å¯å¤±è´¥") else sl = gg.getResults(999999) sz = gg.getResultCount() xgsl = 0 if sz > 999999 then sz = 999999 end for i = 1, sz do pdsz = true for v = 4, #(qmnb) do if pdsz == true then pysz = {} pysz[1] = {} pysz[1].address = sl[i].address + qmnb[v]["offset"] pysz[1].flags = qmnb[v]["type"] szpy = gg.getValues(pysz) pdpd = qmnb[v]["lv"] .. ";" .. szpy[1].value szpd = split(pdpd, ";") tzszpd = szpd[1] pyszpd = szpd[2] if tzszpd == pyszpd then pdjg = true pdsz = true else pdjg = false pdsz = false end end end if pdjg == true then szpy = sl[i].address xgxc(szpy, qmxg) end end if xgjg == true then gg.toast(qmnb[2]["name"] .. "å¼€å¯æˆåŠŸ,æ”¹" .. xgsl .. "æ¡æ•°æ®") else gg.toast(qmnb[2]["name"] .. "å¼€å¯å¤±è´¥") end end end end
gg.toast("75ï¼…...")
function SearchWrite(tb1, tb2, dataType, Name) local lt1={} local lt2={} local mm1={["ä¸»ç‰¹å¾ç "] = tb1[1][1],["ç±»å‹"] = dataType } table.insert(lt1,1,mm1)   for i=2 , #tb1 do     local mm2={["å‰¯ç‰¹å¾ç "] = tb1[i][1],["åç§»"] = tb1[i][2]}     table.insert(lt1,i,mm2)   end   for i=1 , #tb2 do     if tb2[i][2]~=nil then       local mm3={["ä¿®æ”¹"] = tb2[i][1],["åç§»"] = tb2[i][2]}       table.insert(lt2,i,mm3)      else       local mm3={["ä¿®æ”¹"] = false,["åç§»"] = tb2[i][1]}       table.insert(lt2,i,mm3)     end   end   LongTao(lt1, lt2 ) end  function LongTao(Search, Write)   gg.clearResults()   gg.setVisible(false)   lx=Search[1]["ç±»å‹"]   gg.searchNumber(Search[1]["ä¸»ç‰¹å¾ç "], lx)   local count = gg.getResultCount()   local result = gg.getResults(count)   gg.clearResults()   local data = {}   if (count > 0) then     gg.toast("å…±æœç´¢ "..count.." æ¡æ•°æ®")     for i, v in ipairs(result) do       v.isUseful = true     end     for k=2, #Search do       local tmp = {}       local num = Search[k]["å‰¯ç‰¹å¾ç "]       if Search[k]["ç±»å‹"]~= nil then            lx =Search[k]["ç±»å‹"]          else            lx = Search[1]["ç±»å‹"]         end       for i, v in ipairs(result) do         tmp[#tmp+1] = {}         tmp[#tmp].address = v.address + Search[k]["åç§»"]         tmp[#tmp].flags = lx       end       tmp = gg.getValues(tmp)       for i, v in ipairs(tmp) do         if ( tostring(v.value) ~= tostring(num) ) then           result[i].isUseful = false         end       end     end     for i, v in ipairs(result) do       if (v.isUseful) then         data[#data+1] = v.address       end     end     if (#data > 0) then       local t = {}       for i=1, #data do         for k, w in ipairs(Write) do           if w["ç±»å‹"] ~= nil then              lx = w["ç±»å‹"]            else              lx = Search[1]["ç±»å‹"]           end           t[#t+1] = {}           t[#t].address = data[i] + w["åç§»"]           t[#t].flags = lx           if (w["ä¿®æ”¹"]~=nil) and (w["ä¿®æ”¹"]~=false) then             t[#t].value = w["ä¿®æ”¹"]             gg.setValues(t)             if (w["å†»ç»“"] == true) then               local item = {}               item[#item+1] = t[#t]               item[#item].freeze = w["å†»ç»“"]               gg.addListItems(item)             end           end         end       end       gg.loadResults(t)       gg.toast("å…±åç§»Î·"..#t.." æ¡æ•°æ®Î”Î˜")      else       gg.toast("æœªå®šä½åˆ°æ•°æ®ï¼")       return false     end    else     gg.toast("æœªå®šä½åˆ°æ•°æ®ï¼")     return false   end end    local app = {} function Assert(data) if data == nil or data == "" or data == "nil" then return false else return true end end function mearrass(memory, array) if Assert(memory) and Assert(array) then return true else return false end end function typetab(array, type) local datatype = {} for i = 1, #array do if Assert(array[i].type) then table.insert(datatype, i, array[i].type) else if Assert(type) then table.insert(datatype, i, type) else return false end end end return true, datatype end function app.memorysearch(memory, array, type) gg.setVisible(false) local isok = mearrass(memory, array) if isok then local isok, datatype = typetab(array, type) if isok then if Assert(array[1].hv) then gg.clearResults() gg.setRanges(memory) gg.searchNumber(array[1].lv .. "~" .. array[1].hv, datatype[1]) else gg.clearResults() gg.setRanges(memory) gg.searchNumber(array[1].lv, datatype[1]) end if gg.getResultCount() == 0 then return false else local tab = {} local data = gg.getResults(gg.getResultCount()) gg.clearResults() for i = 1, #data do data[i].isok = true end for i = 2, #array do local t = {} local offset = array[i].offset for x = 1, #data do t[#t + 1] = {} t[#t].address = data[x].address + offset t[#t].flags = datatype[i] end local t = gg.getValues(t) for z = 1, #t do if Assert(array[i].hv) then if tonumber(t[z].value) < tonumber(array[i].lv) or tonumber(t[z].value) > tonumber(array[i].hv) then  data[z].isok = false end else if tostring(t[z].value) ~= tostring(array[i].lv) then data[z].isok = false end end end end for i = 1, #data do if data[i].isok then tab[#tab + 1] = data[i].address end end if #tab > 0 then return true, tab else return false end end else print("typeå‚æ•°é”™è¯¯") gg.toast("typeå‚æ•°é”™è¯¯") os.exit() end else print("memory or arrayå‚æ•°é”™è¯¯") gg.toast("memory or arrayå‚æ•°é”™è¯¯") os.exit() end end function app.memoryread(addr, type) local t = {} t[1] = {} t[1].address = addr t[1].flags = type if #t > 0 then return true, gg.getValues(t)[1].value else return false end end function app.memorywrite(addr, type, value, freeze) local t = {} t[1] = {} t[1].address = addr t[1].flags = type t[1].value = value if #t > 0 then if Assert(freeze) then t[1].freeze = freeze return gg.addListItems(t) else return gg.setValues(t) end else return false end end
function setvalue(address,flags,value) PS('ä¿®æ”¹åœ°å€æ•°å€¼(åœ°å€,æ•°å€¼ç±»å‹,è¦ä¿®æ”¹çš„å€¼)') local tt={} tt[1]={} tt[1].address=address tt[1].flags=flags tt[1].value=value gg.setValues(tt) end
gg.sleep(520)
gg.toast("80ï¼…...")
function PS() end function setvalue(address,flags,value) PS('ä¿®æ”¹åœ°å€æ•°å€¼(åœ°å€,æ•°å€¼ç±»å‹,è¦ä¿®æ”¹çš„å€¼)') local tt={} tt[1]={} tt[1].address=address tt[1].flags=flags tt[1].value=value gg.setValues(tt) end
local bx = os.date("%Yå¹´%mæœˆ%dæ—¥%Hæ—¶%Måˆ†%Sç§’")print(bx)bqt={"ğŸ¬","ğŸ“","ğŸ“","ğŸ","ğŸ¡","ğŸ”","ğŸ¥","âœ¡ğŸ“Œ","ğŸ’Ÿ","â„ï¸","ğŸ‘»","ğŸ’›","â­","ğŸº","ğŸ€","ğŸ’£","ğŸˆ¯ï¸","ğŸ€","ğŸ”‹","ğŸ–¼","ğŸ’","ğŸ’™","ğŸ’œ","ğŸ’«","ğŸ’“","ğŸ’–","ğŸ€","âš¡","â˜‘ï¸",}--è„šæœ¬æ ¸å¿ƒï¼Œä¸å¯åˆªé™¤
gg.toast("85ï¼…...")
function getMapRanges() local ranges = {} local r_list = {} local _index = 1 local library = gg.getRangesList("^/data/*.so*$") for index, map in ipairs(library) do if map.type:sub(2, 2) == "w" or map.type == "r-xp" then local name = map.internalName local state = map.state local count = map.count if not r_list[name] then r_list[name] = {} end if not r_list[name][state] then r_list[name][state] = {0, _index} end r_list[name][state][1] = r_list[name][state][1] + 1 r_list[name][state][2] = _index map.count = r_list[name][state][1] table.insert(ranges, map) _index = _index + 1 end end return ranges, r_list end 
function staticstart(map) local ranges = getMapRanges() if not map[3] then map[3] = 1 end for index, value in ipairs(ranges) do local name = value.internalName:gsub("^.*/", "") if map[1] == name and map[2] == value.state and map[3] == value.count then return value.start end end end 
gg.sleep(620)
gg.toast("90ï¼…...")
function S_Pointer(t_So, t_Offset, _bit) local 
function getRanges() local ranges = {} local t = gg.getRangesList('^/data/*.so*$') for i, v in pairs(t) do if v.type:sub(2, 2) == 'w' then table.insert(ranges, v) end end return ranges end
function Get_Address(N_So, Offset, ti_bit) local ti = gg.getTargetInfo() local S_list = getRanges() local _Q = tonumber(0x63dd9d7) local t = {} local _t local _S = nil if ti_bit then _t = 32 else _t = 4 end for i in pairs(S_list) do local _N = S_list[i].internalName:gsub('^.*/', '') if N_So[1] == _N and N_So[2] == S_list[i].state then _S = S_list[i] break end end if _S then t[#t + 1] = {} t[#t].address = _S.start + Offset[1] t[#t].flags = _t if #Offset ~= 1 then for i = 2, #Offset do local S = gg.getValues(t) t = {} for _ in pairs(S) do if not ti.x64 then S[_].value = S[_].value & 0xFFFFFFFF end t[#t + 1] = {} t[#t].address = S[_].value + Offset[i] t[#t].flags = _t end end end _S = t[#t].address end return _S end local _A = string.format('0x%X', Get_Address(t_So, t_Offset, _bit)) return _A end 
gg.toast("95ï¼…...")
function GetValue(address, flag) return gg.getValues({{address = address, flags = flag}})[1].value end 
function GotoPointer(address, offset) local Addr = GetValue(address, 32) & 0xFFFFFFFFFF if offset then for k, v in pairs(offset) do Addr = GetValue(Addr + v, 32) & 0xFFFFFFFFFF end end return Addr end 
function stringToBytes(str)
    local bytes = {}
    for i = 1, #str do
        table.insert(bytes, string.byte(str, i))
    end
    table.insert(bytes, 0)  -- æ·»åŠ å­—ç¬¦ä¸²ç»“æŸç¬¦
    return bytes
end

-- ä¿®æ”¹å†…å­˜ä¸­çš„å­—ç¬¦ä¸²
function modifyString(address, newString)
    local bytes = stringToBytes(newString)
    local values = {}
    for i = 1, #bytes do
        table.insert(values, {address = address + i - 1, flags = gg.TYPE_BYTE, value = bytes[i]})
    end
    gg.setValues(values)
end
lde = {}
lde.gre, lde.sbr, lde.srg, lde.crs = gg.getResults, gg.searchNumber, gg.setRanges, gg.clearResults

-- ç”¨æ–¼ç¯„åœè§£æçš„å„ªåŒ–å‡½æ•¸
function bv(a, sep)
    sep = sep or ","  -- è¨­å®šé»˜èªçš„åˆ†éš”ç¬¦
    local result = {}
    for part in string.gmatch(a, "[^" .. sep .. "]+") do
        table.insert(result, part)
    end
    -- è‹¥åªè§£æåˆ°ä¸€å€‹å€¼ï¼Œå‰‡è¦–ç‚ºå–®ä¸€å€¼ç¯„åœ
    if #result == 1 then
        result[2] = result[1]
    end
    return result
end

-- å„ªåŒ–çš„ so å‡½æ•¸
function so(a, b, c)
    gg.setVisible(false)
    local csn = gg.getRanges()
    gg.setRanges(a[3])
    gg.clearResults()
    gg.searchNumber(a[2], a[4])
    local js = gg.getResultCount()
    local cont = gg.getResults(js)
    gg.clearResults()

    if #cont == 0 then
        gg.setRanges(csn)
        return a[1] .. " é–‹å•Ÿå¤±æ•—"
    end

    local lode, lope, lobe = {}, {}, {}

    for p = 1, #b do
        lode[p] = {}
        for i = 1, #cont do
            lode[p][i] = {
                address = cont[i].address + b[p][2],
                flags = b[p][3] or a[4]
            }
        end
        lode[p] = gg.getValues(lode[p])

        local dbb = bv(b[p][1], "~")  -- ä½¿ç”¨ ~ ä½œç‚ºç¯„åœåˆ†éš”ç¬¦

        for i = 1, #lode[p] do
            local value = tonumber(lode[p][i].value)
            if value and value >= tonumber(dbb[1]) and value <= tonumber(dbb[2]) then
                table.inser